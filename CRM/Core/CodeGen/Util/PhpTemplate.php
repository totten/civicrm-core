<?php

use CCL\ErrorBuffer;

/**
 * Class CRM_Core_CodeGen_Util_PhpTemplate
 */
class CRM_Core_CodeGen_Util_PhpTemplate {

  protected $templateDir;

  protected $vars = [];

  protected $compileCache = [];

  /**
   * CRM_Core_CodeGen_Util_PhpTemplate constructor.
   */
  public function __construct() {
    $base = dirname(dirname(dirname(dirname(__DIR__))));
    $this->assign('generated', "DO NOT EDIT.  Generated by CRM_Core_CodeGen");
    $this->templateDir = "$base/xml/templates";
  }

  /**
   * Run template generator.
   *
   * @param string $inputFileRel
   *   Filename of the template, without a path.
   * @param string $outputFileAbs
   *   Full path to the desired output file.
   */
  public function run($inputFileRel, $outputFileAbs) {
    // REVERT: This generates a debug file
    file_put_contents(
      preg_replace('/\.php$/', '.dbg.php', $outputFileAbs),
      '<' . "?php\n"
      . sprintf("extract(%s);\n", var_export(static::toBasicTypes($this->vars), 1))
      . $this->getTranslatedFile($inputFileRel));

    // And this does the real work
    $contents = $this->fetch($inputFileRel);
    $contents = $this->normalizePhpCode($contents);
    file_put_contents($outputFileAbs, $contents);
  }

  /**
   * Fetch via Smarty.
   *
   * @param string $_tplFileRel
   *
   * @return string
   */
  public function fetch($_tplFileRel) {
    $_tplCode = $this->getTranslatedFile($_tplFileRel);
    $result = $this->capture(function() use ($_tplFileRel, $_tplCode) {
      extract(static::toBasicTypes($this->vars));
      eval($_tplCode);
    });
    return $result;
  }

  /**
   * @param $key
   * @param $value
   */
  public function assign($key, $value) {
    $this->vars[$key] = $value;
  }

  /**
   * @param $contents
   *
   * @return string|string[]|null
   */
  private function normalizePhpCode($contents) {
    // The beautifier isn't as beautiful as one would hope. Here's some extra string fudging.
    $replacements = [
      ') ,' => '),',
      "\n  }\n}\n" => "\n  }\n\n}\n",
      '=> true,' => '=> TRUE,',
      '=> false,' => '=> FALSE,',
      'static ::' => 'static::',
      'use\\' => 'use ',
    ];
    $contents = str_replace(array_keys($replacements), array_values($replacements), $contents);
    $contents = preg_replace('#(\s*)\\/\\*\\*#', "\n\$1/**", $contents);

    // Convert old array syntax to new square brackets
    $contents = CRM_Core_CodeGen_Util_ArraySyntaxConverter::convert($contents);

    // Remove numeric array keys (assuming its non-associative)
    $contents = preg_replace("#  '\\d+' => #", "  ", $contents);

    // Remove extra lines between functions
    $contents = preg_replace(';(\n\n)\n+;m', '$1', $contents);

    // Ensure file ends with a newline
    if (substr($contents, -1) !== "\n") {
      $contents .= "\n";
    }
    return $contents;
  }

  /**
   * Execute a callable function, capturing any "echo"ed or "print"ed data.
   *
   * @param callable $callable
   * @return false|string
   */
  private static function capture($callable) {
    $errorBuffer = ErrorBuffer::create()->start();
    ob_start();
    try {
      $callable();
    } finally {
      $outputData = ob_get_contents();
      ob_end_clean();
      $errorBuffer->stop();
      foreach ($errorBuffer->getLines() as $error) {
        fwrite(STDERR, "$error\n");
      }
    }

    if ($errorBuffer->isFatal()) {
      throw new \RuntimeException("Fatal template error");
    }

    unset($errorBuffer);
    return $outputData;
  }

  /**
   * Translate from MetaPHP notation to executable PHP code.
   *
   * MetaPHP looks like regular, syntactically valid PHP. However, it is actually
   * a template. It supports a handful of notations:
   *
   * - MetaPHP-constants: `__ECHO_*` will output a variable as part of the PHP code. This is outputting PHP symbols (class-names, method-names, etc).
   * - MetaPHP-constants: `__EXPORT_*` will export a variable via var_export. This is useful for transferring data.
   * - MetaPHP-functions: `__ECHO('$expr')` will be replaced by the value of `$expr`.
   * - MetaPHP-functions: `__EXPORT('$expr')` will export a variable via var_export().
   * - MetaPHP-comments: `// META:` will be treated as an executable statement.
   *
   * For example, suppose you have a variable `$fullClass`. You could generate a class with:
   *
   * class __ECHO_fullClass extends \Foo\Bar { public function doStuff() {...} }
   *
   * @param string $tpl
   *   Meta-PHP (in original format)
   * @return string
   *   Meta-PHP (in executable format)
   */
  private static function translate($tpl) {
    $constRE = '([A-Za-z0-9_]+)';
    $stringRE = '([^\']+)';
    $regex = "/(__(ECHO|EXPORT)(_){$constRE}|__(ECHO|EXPORT)(\()\\\'{$stringRE}\\\'\))/";

    $lines = explode("\n", trim($tpl));
    foreach ($lines as &$line) {
      if (preg_match(';^ *// *META:(.*);', $line, $m)) {
        $line = $m[1];
      }
      else {
        $line = 'echo ' . var_export($line, 1) . '."\n"' . ";";
        $line = str_replace("/" . "*", "/' . '*", $line);
        //    $line = str_replace("<" . "?", "<' . '?", $line);
        $line = preg_replace_callback($regex,
          function ($m) {
            $outFormat = !empty($m[2]) ? $m[2] : $m[5];
            $inNotation = !empty($m[2]) ? $m[3] : $m[6];
            $expr = !empty($m[2]) ? $m[4] : $m[7];

            $buf = '';
            if ($outFormat === 'EXPORT') {
              $buf .= 'var_export(';
            }
            if ($inNotation === '(') {
              $buf .= $expr;
            }
            if ($inNotation === '_') {
              $buf .= '$';
              $parts = explode('_', $expr);
              $buf .= array_shift($parts);
              $buf .= implode('', array_map(
                function ($part) {
                  return '["' . $part . '"]';
                },
                $parts
              ));
            }
            if ($outFormat === 'EXPORT') {
              $buf .= ', 1)';
            }
            return "' . $buf .'";
          },
          $line);
      }
    }
    return trim(implode("\n", $lines)) . "\n";
  }

  /**
   * @param $_tplFileRel
   *
   * @return mixed
   */
  private function getTranslatedFile($_tplFileRel) {
    if (!isset($this->compileCache[$_tplFileRel])) {
      $inputFileAbs = $this->templateDir . DIRECTORY_SEPARATOR . $_tplFileRel;
      $this->compileCache[$_tplFileRel] = CRM_Core_CodeGen_Util_PhpTemplate::translate(file_get_contents($inputFileAbs));
    }
    $_tplCode = $this->compileCache[$_tplFileRel];
    return $_tplCode;
  }

  /**
   * Given a tree of data, search for any complex data (e.g. XML elements) and attempt to normalize them.
   *
   * @param mixed $v
   *   Data-tree
   * @return mixed
   *   Filtered data-tree
   * @throws \Exception
   */
  protected static function toBasicTypes($v) {
    if (is_scalar($v) || $v === NULL) {
      return $v;
    }
    if ($v instanceof SimpleXMLElement) {
      return (string) $v;
    }
    if (is_array($v)) {
      return array_map([__CLASS__, 'toBasicTypes'], $v);
    }
    throw new \Exception("Assigned funny value:" . var_dump($v));
  }

}
